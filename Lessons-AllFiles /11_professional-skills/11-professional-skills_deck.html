<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Module 3: R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Amy Farrow" />
    <meta name="date" content="2022-06-24" />
    <script src="libs/header-attrs-2.14/header-attrs.js"></script>
    <script src="libs/kePrint-0.0.1/kePrint.js"></script>
    <link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Module 3: R
]
.subtitle[
## Professional Skills
]
.author[
### Amy Farrow
]
.institute[
### Data Sciences Institute, University of Toronto
]
.date[
### 2022-06-24
]

---






# Overview

- Presenting Data Science
- Presenting Your Work in R
- Managing Data Science Projects

---

class: inverse, center, middle

# Presenting Data Science

---

## Challenges

- A target audience that will likely not have an equivalent technical understanding to your own
- Communicating the limitations while promoting your work
- Keeping it interesting
- Including the appropriate level of persuasion

---

&lt;video width="320" height="240"&gt;
&lt;source src="https://www.youtube.com/watch?v=CzrCADdsXwE" type="video/mp4"&gt;
&lt;/video&gt;

---

## Strategies

- Don't just think in terms of performance and technical ability of your analysis and models. Consider:
-- Are your models believable?
-- What evidence have you offered? How have you built trust?
- Don't overcomplicate it
-- What details are necessary to understanding the core goals, abilities, and limitations of your project? Which are not?
- Tailor your message
-- Who are you presenting to? What level of knowledge can you assume?
- Always have takeaway messages
-- In a presentation where some viewers might get confused along the way, a strong structure and final message can keep everyone on track

---

class: inverse, center, middle

# Practical Considerations: Presenting Your Work in R

---

## Presenting Data Tables

There are many libraries to format tables for readable and professional-looking outputs. Some only work for certain kinds of outputs (html, pdf, or docx), so you may have to pick a library that is the best fit for you.

`kableExtra` is a library for formatting table output in html and pdf.

A table without formatting looks like this:


```r
my_table &lt;- tibble(categoryA = c(1,2,3, 4),
       categoryB = c("one", "two", "three", "four"),
       other = c(14.3, 182.5, 54.0, 33.1))
my_table
```

```
## # A tibble: 4 Ã— 3
##   categoryA categoryB other
##       &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;
## 1         1 one        14.3
## 2         2 two       182. 
## 3         3 three      54  
## 4         4 four       33.1
```

---

With formatting:


```r
my_table %&gt;%
  kable(caption = "My Table", booktabs = TRUE,
               col.names = c("A", "B", "Other")) %&gt;%
  pack_rows("Run 1", 1, 2) %&gt;%
  pack_rows("Run 2", 3, 4) %&gt;%
  add_header_above(c("Categories" = 2, " " = 1))  %&gt;%
  kable_styling()
```

&lt;table class="table" style="margin-left: auto; margin-right: auto;"&gt;
&lt;caption&gt;My Table&lt;/caption&gt;
 &lt;thead&gt;
&lt;tr&gt;
&lt;th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2"&gt;&lt;div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; "&gt;Categories&lt;/div&gt;&lt;/th&gt;
&lt;th style="empty-cells: hide;border-bottom:hidden;" colspan="1"&gt;&lt;/th&gt;
&lt;/tr&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; A &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; B &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Other &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr grouplength="2"&gt;&lt;td colspan="3" style="border-bottom: 1px solid;"&gt;&lt;strong&gt;Run 1&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
   &lt;td style="text-align:right;padding-left: 2em;" indentlevel="1"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; one &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 14.3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;padding-left: 2em;" indentlevel="1"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; two &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 182.5 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr grouplength="2"&gt;&lt;td colspan="3" style="border-bottom: 1px solid;"&gt;&lt;strong&gt;Run 2&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
   &lt;td style="text-align:right;padding-left: 2em;" indentlevel="1"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; three &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 54.0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;padding-left: 2em;" indentlevel="1"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; four &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 33.1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---

## Formatting Reports

The package `bookdown` can be used to cross-reference figures and tables, add citations, create a table of contents, and more.

For the output to work correctly, you want to have blank lines in your markdown in between parts: i.e. between a paragraph and the next paragraph, a paragraph and a code chunk, a code chunk and a paragraph, or a code chunk and the next code chunk.

A typical header for such a report would look like:

&lt;img src="report-header.png" width="1500" /&gt;

---

### Breaking down the header


```r
---
title: "TITLE"
subtitle: "SUBTITLE"
author: "YOUR NAME"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  bookdown::pdf_document2:
    toc: yes
abstract: "ABSTRACT"
bibliography: references.bib
---
```

- The title, subtitle, author, and abstract can be inserted in the quotes.
- The date is automatically generated based on the system time and date.
- The output for the report is pdf_document2, a `bookdown` format.
- A table of contents will be included in the output.
- The bibliography will be created based on a bib file called references.

---

### Breaking down the setup chunk


```r
knitr::opts_chunk$set(
  echo = FALSE,    # hide source code in output
  message = FALSE, # hide messages from  code in output
  warning = FALSE  # hide warnings from code in output
  )

library() # load libraries here, including bookdown
```

- We set all the chuns to hide code, warnings, and messages by default, while still showing the code output.
- All necessary libraries are loaded in the chunk.

---

A typical end of a report would look like this:

&lt;img src="report-tail.png" width="1000" /&gt;

---

### Breaking down the end of the report


```r
# Conclusion

CONCLUSION

\newpage


# (APPENDIX) Appendix {-} 

# Appendix A

APPENDICES


\newpage

# References
```

- Our last report section is the conclusion. We want a page break in between the conclusion and the appendices.
- We also want a page break before our references section. References will be automatically attached to the end of the report by `bookdown`.

---

### Referencing

Each work that you wish to cite will need to be present in the .bib file, where it will be given a unique nickname:

&lt;img src="bib.png" width="1000" /&gt;

To reference it in your text, you will refer to that nickname again, in the form `@mycitedwork` or `[@mycitedwork]`:

&lt;img src="citation.png" width="1000" /&gt;

---

### Cross-referencing figures

&lt;img src="figures.png" width="1000" /&gt;

- Each chunk with a figure (ex. ggplot graph) will require a name (alphanumeric, excluding spaces and underscores) and a caption ("A CAPTION"). These must be unique to each figure.
- To reference the figure, you can use the code `\@ref(fig: )`, with the figure name included in the brackets.

---

### Cross-referencing tables

&lt;img src="tables.png" width="1000" /&gt;

- Each chunk with a table will also need a unique name.
- In the body of your code chunk, you also need to give the table a caption. Exactly how this is accomplished will depend on what table formatting package you are using.
- To reference the table, you can use the code `\@ref(tab: )`, with the table name included in the brackets.

---

class: inverse, center, middle

# Managing Data Science Projects

---

## Objectives

Before embarking on a project, the team should be able to provide answers to each of the following:

1. Regulatory requirements
2. Frequency of model updating
3. Consequences of being wrong
4. Volume of data
5. Method for users to access results
6. Level of access/connection between the data science team and end users

---

## Skills

1. Do the skills currently exist?
2. Are the people with the skills available?
3. What are the consequences of failing to complete?
4. How urgent is the project?
5. Would it be difficult to hire a temp?

---

## Data

1. Has the team worked with this data before?
2. What is the data provenance?
3. Would you benefit from more data, and would acquiring it be feasible?
4. Do you have permissions required to use the data?
5. Will the data be refreshed frequently enough for your model?

---

## Discussion questions

1. What do you think is the biggest challenge in communicating data science to non-data scientists?
2. How can you balance giving a thorough presentation and making the work accessible?
3. What questions would you add to the data science project checklist?


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
